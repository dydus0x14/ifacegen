/**
 * @generated
 *
 * AUTOGENERATED. DO NOT EDIT! 
 *
 */

#import "gittypes.h"
#import "IFServiceClient+Protected.h" 

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused"
#pragma clang diagnostic ignored "-Wundeclared-selector"

static const NSUInteger jsonFormatOption = 
#ifdef DEBUG
	NSJSONWritingPrettyPrinted;
#else
	0;
#endif

@implementation GitUser

- (instancetype)initWithLogin:(NSString*)login
	andTheId:(int64_t)theId
	andAvatarUrl:(NSString*)avatarUrl
	andName:(NSString*)name {
	if (self=[super init]) {
		_login = login;
		_theId = theId;
		_avatarUrl = avatarUrl;
		_name = name;
	}
	return self;
}

- (NSDictionary*)dictionaryWithError:(NSError* __autoreleasing*)error {
	return @{
		@"login":(self.login == nil ? [NSNull null] : self.login),
		@"id":@(self.theId),
		@"avatar_url":(self.avatarUrl == nil ? [NSNull null] : self.avatarUrl),
		@"name":(self.name == nil ? [NSNull null] : self.name)
	};
}

- (NSData*)dumpWithError:(NSError* __autoreleasing*)error {
	NSDictionary* dict = [self dictionaryWithError:error];
	if (*error) return nil;
	else return [NSJSONSerialization dataWithJSONObject:[self dictionaryWithError:error] options:jsonFormatOption error:error];
}

- (void)readDictionary:(NSDictionary*)dict withError:(NSError* __autoreleasing*)error {
	id tmp;
	self.login = ( tmp = dict[@"login"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.theId = ( tmp = dict[@"id"], [tmp isEqual:[NSNull null]] ? 0L : ((NSNumber*)tmp).longLongValue );
	self.avatarUrl = ( tmp = dict[@"avatar_url"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.name = ( tmp = dict[@"name"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
}

- (instancetype)initWithDictionary:(NSDictionary*)dictionary error:(NSError* __autoreleasing*)error {
	if ( dictionary == nil ) return nil;
	if (self = [super init]) {
		[self readDictionary:dictionary withError:error];
		if ( error && *error != nil ) self = nil;
	}
	return self;
}

- (instancetype)initWithJSONData:(NSData*)jsonData error:(NSError* __autoreleasing*)error {
	if ( jsonData == nil ) return nil;
	if (self = [super init]) {
		NSDictionary* dict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingAllowFragments error:error];
		if ( error && *error != nil ) { self = nil; return nil; }
		[self readDictionary:dict withError:error];
		if ( error && *error != nil ) self = nil;
	}
	return self;
}

@end

@implementation GitPublicUser

- (instancetype)initWithLogin:(NSString*)login
	andTheId:(int64_t)theId
	andAvatarUrl:(NSString*)avatarUrl
	andName:(NSString*)name
	andEmail:(NSString*)email
	andPublicRepos:(int32_t)publicRepos
	andFollowers:(int32_t)followers
	andFollowing:(int32_t)following {
	if (self = [super initWithLogin:login
						andTheId:theId
						andAvatarUrl:avatarUrl
						andName:name]) {
		_email = email;
		_publicRepos = publicRepos;
		_followers = followers;
		_following = following;
	}
	return self;
}

- (NSDictionary*)dictionaryWithError:(NSError* __autoreleasing*)error {
	return @{
		@"login":(self.login == nil ? [NSNull null] : self.login),
		@"id":@(self.theId),
		@"avatar_url":(self.avatarUrl == nil ? [NSNull null] : self.avatarUrl),
		@"name":(self.name == nil ? [NSNull null] : self.name),
		@"email":(self.email == nil ? [NSNull null] : self.email),
		@"public_repos":@(self.publicRepos),
		@"followers":@(self.followers),
		@"following":@(self.following)
	};
}

- (NSData*)dumpWithError:(NSError* __autoreleasing*)error {
	NSDictionary* dict = [self dictionaryWithError:error];
	if (*error) return nil;
	else return [NSJSONSerialization dataWithJSONObject:[self dictionaryWithError:error] options:jsonFormatOption error:error];
}

- (void)readDictionary:(NSDictionary*)dict withError:(NSError* __autoreleasing*)error {
	id tmp;
	self.login = ( tmp = dict[@"login"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.theId = ( tmp = dict[@"id"], [tmp isEqual:[NSNull null]] ? 0L : ((NSNumber*)tmp).longLongValue );
	self.avatarUrl = ( tmp = dict[@"avatar_url"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.name = ( tmp = dict[@"name"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.email = ( tmp = dict[@"email"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.publicRepos = ( tmp = dict[@"public_repos"], [tmp isEqual:[NSNull null]] ? 0 : ((NSNumber*)tmp).intValue );
	self.followers = ( tmp = dict[@"followers"], [tmp isEqual:[NSNull null]] ? 0 : ((NSNumber*)tmp).intValue );
	self.following = ( tmp = dict[@"following"], [tmp isEqual:[NSNull null]] ? 0 : ((NSNumber*)tmp).intValue );
}

- (instancetype)initWithDictionary:(NSDictionary*)dictionary error:(NSError* __autoreleasing*)error {
	if ( dictionary == nil ) return nil;
	if (self = [super init]) {
		[self readDictionary:dictionary withError:error];
		if ( error && *error != nil ) self = nil;
	}
	return self;
}

- (instancetype)initWithJSONData:(NSData*)jsonData error:(NSError* __autoreleasing*)error {
	if ( jsonData == nil ) return nil;
	if (self = [super init]) {
		NSDictionary* dict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingAllowFragments error:error];
		if ( error && *error != nil ) { self = nil; return nil; }
		[self readDictionary:dict withError:error];
		if ( error && *error != nil ) self = nil;
	}
	return self;
}

@end

@implementation GitRepo

- (instancetype)initWithTheId:(int32_t)theId
	andName:(NSString*)name
	andOwner:(GitUser*)owner
	andTheDescription:(NSString*)theDescription
	andUrl:(NSString*)url
	andForks:(int32_t)forks
	andOpenIssues:(int32_t)openIssues
	andWatchers:(int32_t)watchers {
	if (self=[super init]) {
		_theId = theId;
		_name = name;
		_owner = owner;
		_theDescription = theDescription;
		_url = url;
		_forks = forks;
		_openIssues = openIssues;
		_watchers = watchers;
	}
	return self;
}

- (NSDictionary*)dictionaryWithError:(NSError* __autoreleasing*)error {
	return @{
		@"id":@(self.theId),
		@"name":(self.name == nil ? [NSNull null] : self.name),
		@"owner":[self.owner dictionaryWithError:error],
		@"description":(self.theDescription == nil ? [NSNull null] : self.theDescription),
		@"url":(self.url == nil ? [NSNull null] : self.url),
		@"forks":@(self.forks),
		@"open_issues":@(self.openIssues),
		@"watchers":@(self.watchers)
	};
}

- (NSData*)dumpWithError:(NSError* __autoreleasing*)error {
	NSDictionary* dict = [self dictionaryWithError:error];
	if (*error) return nil;
	else return [NSJSONSerialization dataWithJSONObject:[self dictionaryWithError:error] options:jsonFormatOption error:error];
}

- (void)readDictionary:(NSDictionary*)dict withError:(NSError* __autoreleasing*)error {
	id tmp;
	self.theId = ( tmp = dict[@"id"], [tmp isEqual:[NSNull null]] ? 0 : ((NSNumber*)tmp).intValue );
	self.name = ( tmp = dict[@"name"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.owner = [[GitUser alloc] initWithDictionary:dict[@"owner"] error:error];
	self.theDescription = ( tmp = dict[@"description"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.url = ( tmp = dict[@"url"], [tmp isEqual:[NSNull null]] ? nil : (NSString*)tmp );
	self.forks = ( tmp = dict[@"forks"], [tmp isEqual:[NSNull null]] ? 0 : ((NSNumber*)tmp).intValue );
	self.openIssues = ( tmp = dict[@"open_issues"], [tmp isEqual:[NSNull null]] ? 0 : ((NSNumber*)tmp).intValue );
	self.watchers = ( tmp = dict[@"watchers"], [tmp isEqual:[NSNull null]] ? 0 : ((NSNumber*)tmp).intValue );
}

- (instancetype)initWithDictionary:(NSDictionary*)dictionary error:(NSError* __autoreleasing*)error {
	if ( dictionary == nil ) return nil;
	if (self = [super init]) {
		[self readDictionary:dictionary withError:error];
		if ( error && *error != nil ) self = nil;
	}
	return self;
}

- (instancetype)initWithJSONData:(NSData*)jsonData error:(NSError* __autoreleasing*)error {
	if ( jsonData == nil ) return nil;
	if (self = [super init]) {
		NSDictionary* dict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingAllowFragments error:error];
		if ( error && *error != nil ) { self = nil; return nil; }
		[self readDictionary:dict withError:error];
		if ( error && *error != nil ) self = nil;
	}
	return self;
}

@end




#pragma clang diagnostic pop

